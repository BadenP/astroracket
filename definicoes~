#lang racket/gui

(provide (all-defined-out))

(define width 1255)
(define height 768)
(define IMAGE-WIDTH 50)
(define IMAGE-HEIGHT 60)

(define frame (new frame%
                 [label "AstroRacket"]
                 [width width]
                 [height height]))

; Imagens dos personagens
(define astronauta-correndo-esquerda (list (make-object bitmap% "imagens/astronauta-ce1.png")
                                      (make-object bitmap% "imagens/astronauta-ce2.png")
                                      (make-object bitmap% "imagens/astronauta-ce3.png")
                                      (make-object bitmap% "imagens/astronauta-ce4.png")))
(define astronauta-correndo-direita (list (make-object bitmap% "imagens/astronauta-cr1.png")
                                     (make-object bitmap% "imagens/astronauta-cr2.png")
                                     (make-object bitmap% "imagens/astronauta-cr3.png")
                                     (make-object bitmap% "imagens/astronauta-cr4.png")))
(define astronauta-parado-direita (list (make-object bitmap% "imagens/astronauta-pe1.png")
                                       (make-object bitmap% "imagens/astronauta-pe2.png")
                                       (make-object bitmap% "imagens/astronauta-pe3.png")
                                       (make-object bitmap% "imagens/astronauta-pe3.png")))
(define astronauta-parado-esquerda (list (make-object bitmap% "imagens/astronauta-pr1.png")
                                      (make-object bitmap% "imagens/astronauta-pr2.png")
                                      (make-object bitmap% "imagens/astronauta-pr3.png")
                                      (make-object bitmap% "imagens/astronauta-pr3.png")))
(define alien (list (make-object bitmap% "imagens/alien1.png")
                    (make-object bitmap% "imagens/alien2.png")
                    (make-object bitmap% "imagens/alien3.png")
                    (make-object bitmap% "imagens/alien4.png")))
(define coin-image (make-object bitmap% "icon.png")) 
(define background-image (make-object bitmap% "imagens/backg.png"))
(define caixa (make-object bitmap% "imagens/caixa.png"))
(define yoshi (make-object bitmap% "imagens/yoshi.png"))
(define nave-p (make-object bitmap% "imagens/nave-p.png"))
(define nave-1 (make-object bitmap% "imagens/nave-1.png"))
(define nave-2 (make-object bitmap% "imagens/nave-2.png"))
(define nave-3 (make-object bitmap% "imagens/nave-3.png"))

    (define lista-textos
      '(
        ("Olá, Astro. Seja bem-vindo.

Neste mundo, as máquinas conquistaram a Terra e você é o último humano que resta. Logo, a esperança da humanidade repousa em seus ombros. Sua missão é aprender Racket para que possa desenvolver soluções para derrotar as máquinas, e assim recuperar o controle do planeta. Estarei aqui para te ajudar nessa jornada! Vou te fornecer os fundamentos e iremos praticar exercícios para que você adquira o conhecimento necessário para completar sua missão.

[sempre pressione a tecla enter para avançar os diálogos]" "")

        ("Vamos começar a aprender sobre Racket, uma linguagem que suporta a programação funcional! Programação funcional é um paradigma de programação em que os programas são
descritos com aplicação e composição de funções, ela evita mudança de estado e efeitos colaterais. Ou seja, não podemos alterar o valor das variáveis declaradas em Racket. Uma função é um conjunto de expressões que mapeia valores de entrada para valores de saída.

As expressões são entidades sintáticas que quando avaliadas produzem um valor. Consistem de um literal ou uma função primitiva. Exemplos:

Literais de tipos primitivos:

• Inteiros: 1345
• Racionais: 1/3
• Complexos com as partes real e imaginária exatas
• Ponto flutuante: 2.65
• Complexos com parte real ou imaginária inexata
• Booleano: #t para verdadeiro ou #f para falso
• Strings: ''Seu nome''

Também há muitos outros tipos de funções primitivas:

• Aritméticas: +, -, *, /
• Relacionais: >, >=, <, <=, =
• Strings: string-length, string-append, number->string, string->number

Além de muitas outras..." "")

        ("O processo de avaliação de expressões de literais considera o valor que um literal representa, enquanto para funções primitivas é avaliada a sequência de instruções de máquina associada com a função. Uma expressão que representa uma função pode ser combinada com expressões que representam dados. Veja mais alguns exemplos:
> #t
#t
> 231
231
> ''Banana''
''Banana''
> +
#<procedure:+>
> 34
34
> (+ 3 4)
7
> (* 2 6)
12
> +
#<procedure:+>.
> (+ 12 56)
68
> (* 4 20)
80
> (> 4 5)
#f
> (string-append ''Apenas '' ''um '' ''teste'')
''Apenas um teste''" "")

        ("Este tipo de expressão é chamado de combinação, consiste de uma lista de expresssões entre parênteses. A expressão mais a esquerda é o operador e as outras expressões são os operandos. O valor de uma combinação é obtido aplicando a função especificada pelo operador aos argumentos, que são os valores dos operandos. A convenção de colocar o operador a esquerda dos operandos é chamada de notação pré-fixa. Portanto, em Racket utilizamos a notação pré-fixa e como vantagem as funções podem receber um número variado de argumentos! Exemplo:

> (* 2 8 10 1)
160

Combinações também podem ser aninhadas facilmente, isto  é, os elementos das combinações podem também ser combinações:

> (+ (* 3 5) (- 10 6) 5)
24
> (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
57

Sendo assim, a definição de expressão também inclui as combinações. Uma expressão consiste de um literal, uma função primitiva, ou uma combinação." "")

        ("Chegou a hora de praticar! Irei te fazer algumas perguntas sobre os fundamentos que vimos até então, responda corretamente os desafios para que você possa ganhar RacketPoints, seus pontos de conhecimento em Racket! Quanto mais pontos você conseguir acumular durante seus desafios, melhor será sua recompensa para te ajudar a retomar o controle da Terra!" "") 
        ("Sendo assim, o que seria retornado de acordo com a expressão (+ 20 12 2)?" "34" "Dica: lembre-se que em Racket a notação é pré-fixa! O operador sempre está a esquerda e os operandos a direita, ou seja, neste caso estamos utilizando o operador + para efetuar a operação entre os operandos 20, 12 e 2.")
        ("E o que seria retornado ao inserir 43?" "43" "dica")
        ("Insira o retorno obitdo para a expressão (- 123 12 2) " "109"  "dica")
        ("E o que seria retornado para a expressão(+ (* 2 4) (- 4 6))?" "6"  "dica")
        ("Agora iremos aprender sobre definições. Definições servem para dar nome a objetos computacionais, sejam dados ou funções. É a forma de abstração mais elementar. Em Racket, definições são feitas com o uso da palavra define:
> (define x 10)
> (define y (+ x 24))
> y
34

Quando o interpretador encontra uma construção do tipo (define <nome> <exp>) ele associa <nome> ao valor obtido pela avaliação de <exp>. A avaliação de um nome resulta no objeto associado a ele na sua definição. A memória que armazena as associações entre nomes e objetos é chamada de ambiente!" "")

        ("O processo de avaliação de expressões não se aplica a definições. O uso de (define x 10) não implica na aplicação da função define a dois argumentos, sua finalidade é associar o valor 10 à variável x. Portanto, (define x 10) não é uma combinação. Exceções à regra geral de avaliação de expressões são conhecidas como formas especiais.

• define é uma forma especial.
• Cada forma especial tem sua própria regra de avaliação.

O Racket possui poucas formas especiais, o que facilita a aprendizagem rápida da sintaxe da linguagem. Além disso, é possível criar definições de novas funções, chamadas de funções compostas, usando a sintaxe geral:

(define (<nome> <parâmetros>) <corpo>)

Exemplos:

> (define (quadrado x)
  (* x x))
> (define (soma-quadrados a b)
  (+ (quadrado a) (quadrado b)))
> (quadrado 5)
25
> (quadrado (+ 2 6))
64
> (soma-quadrados (+ 2 2) 3)
25

Observe que as funções compostas (definidas pelo usuário) são utilizadas da mesma forma que as funções pré-definidas." "")

        ("É sua vez de praticar! Defina uma variável chamada raio-terra de valor igual a 6.371" "(define raio-terra 6.371)"  "dica")

        ("O que é retornado quando o interpreador avalia a sequência abaixo?

(define a 3) 
(define b (+ a 1))
(+ a b (* a b))" "19"  "dica")

        ("
(define a 3) 
(define b (+ a 1))

Considerando ainda o contexto das definições anteriores, o que é retornado ao avaliar a seguinte expressão? 
(= a b)" "#f"  "dica")

        ("Agora iremos aprender sobre condicionais! A forma especial cond é utilizada para especificar funções deste tipo. Olhe só um exemplo para verificar o módulo de um número:

(define (abs x)
  (cond
    [(>= x 0) x]
    [(< x 0) (- x)]))

Como as duas condições são mutuamente excludentes, podemos usar o else

(define (abs x)
  (cond
    [(>= x 0) x]
    [else (- x)]))

A forma geral do cond é:
(cond
  (<p1> <e1>)
  (<p2> <e2>)
  (<p3> <e3>)
  ...
  [(else <en>)])

Cada par (<p> <e>) é chamado de cláusula. A primeira expressão de uma cláusula é chamada de predicado, isto  é, uma expressão cujo o valor é interpretado como verdadeiro ou falso. A segunda expressão de uma cláusula é chamada de consequente.

Expressões cond são avaliadas da seguinte maneira: se o primeiro predicado não é um valor, avalie o predicado e o substitua pelo seu valor. Ou seja, substitua todo o cond por um novo cond onde o primeiro predicado foi substituído pelo seu valor
Se o primeiro predicado é true ou else, substitua a expressão cond inteira pelo primeiro consequente Se o primeiro predicado é false, remove a primeira cláusula. Isto é, substitua o cond por um novo cond sem a primeira cláusula
Se não tem mais cláusula, sinalize um erro." "")

        ("A forma especial if pode ser usada da seguinte forma:

(if <predicado> <consequente> <alternativa>)

Expressões if são avaliadas da seguinte maneira: se o predicado não é um valor, avalie o predicado e o substitua pelo seu valor. Se o predicado é true, substitua toda a expressão if pelo consequente. Se o predicado é false, substitua toda a expressão if pela alternativa
         
Agora podemos responder de acordo com o contexto anterior:
(define a 3) 
(define b (+ a 1))

Considerando as definições acima, responda o que será retornado ao avaliar a seguinte expressão:

(if (and (> b a) (< b (* a b))) b a)" "4"  "dica")

        ("
Definições anteriores:
(define a 3) 
(define b (+ a 1))

E o que será retornado ao avaliar a seguinte expressão?

(* (cond [(> a b) a]
         [(< a b) b]
         [else -1])
         (+ a 1))" "16"  "dica")

        ("Ok Astro, agora veremos sobre operadores lógicos! Predicados podem ser compostos usando as formas especiais and e or e a função not. A função (not <e>) produz #t quando <e> for avaliado para um valor falso, e #f caso contrário:

> (not (> 5 2))
#f
> (not (< 5 2))
#t

Para o operador and (and <e1> ... <en>):
Se não há expressões, retorna #t.
Se a primeira expressão não é um valor, ela é avaliada e substituída pelo seu valor. 
Se a primeira expressão é falsa, retorna #f.
Se a primeira expressão é verdadeira, substitua a expressão and por uma nova expressão and sem a primeira expressão. 
O Racket mantém os valores true no passo a passo, ou seja, não elimina os valores true.

Exemplo de uso do and:

> (and (= 2 2) (> 3 1))   
#t

Para o operador (or <e1> ... <en>):
  
Se não há expressões, retorna #f 
Se a primeira expressão não é um valor, ela é avaliada e substituída pelo seu valor.
Se a primeira expressão é verdadeira, retorna #t.
Se a primeira expressão é falsa, substitua a expressão or por uma nova expressão or sem a primeira expressão. 
O Racket mantém os valores false no passo a passo, ou seja, não elimina os valores false.


Exemplo de uso do or:

> (or (> 5 2) (= 3 2))
#t" "")

        ("Veremos agora o processo para criar funções em Racket, guiado pelas receitas de projeto do livro How to Design Programs. Aqui está um resumo breve dos passos para fazer funções em Racket:

    Assinatura, Propósito e Cabeçalho:
        Declare a assinatura da função indicando os tipos de entrada e saída.
        Escreva o propósito da função, descrevendo o que ela faz.
        Formule o cabeçalho da função com a estrutura (define (<nome_funcao> <parâmetros>) <corpo>)

    Exemplos:
        Forneça exemplos que ilustrem o comportamento da função.
        Inclua casos simples e casos especiais.

    Template:
        Construa um template que define a estrutura básica da função, considerando os tipos de dados dos parâmetros.
        Utilize o template para guiar o desenvolvimento da função.

    Código do Corpo da Função:
        Escreva o código interno da função, seguindo a lógica delineada nos passos anteriores.
        Utilize estruturas de controle, como if, cond, e estruturas de dados, conforme necessário.

    Teste e Depuração:
        Teste a função com diversos casos, verificando se ela produz os resultados esperados.
        Depure a função, identificando e corrigindo possíveis erros ou melhorando sua eficiência." "")

        ("Veremos um exemplo para definir uma função que calcule o dobro de uma dado valor:

Passo 1: Assinatura, propósito e cabeçalho
;; Número -> número 
;; Produz o dobro de n.
(define (dobro n) 0)

As convenções utilizadas são o nome do tipo usando CamelCase e o nome da função em minúsculo usando - para separar as palavras. Também podemos utilizar ; ou ;; para comentar linhas ao escrever códigos em Racket, e para comentários em bloco podemos utilizar a estrutura #||#:
Exemplos de uso dos comentários:
;comentário em linha única
#| comentario 
   em
   bloco  |#

Passo 2: Exemplos

;; Número -> número 
;; Produz o dobro de n
(check-equal? (dobro 0) 0)
(check-equal? (dobro 4) 8)
(check-equal? (dobro -2) -4)))
(define (dobro n) 0)

Repare que o uso da estrutura (check-equal? <valor a> <valor b>) serve para testes em Racket, verificando se o resultado de uma função aplicando argumentos específicos será igual ao resultado esperado.

Passo 3: Template

Usaremos um template de tipos atômicos ''fun-for-atomic'', pois o parâmetro da função dobro é um número.

;; Número -> número 
;; Produz o dobro de n
(check-equal? (dobro 0) 0)
(check-equal? (dobro 4) 8)
(check-equal? (dobro -2) -4)))
;(define (dobro n) 0)
(define (fun-for-atomic a)
    (... a))

Então, ajustamos os nomes no template para a função que estamos definindo:

;; Número -> número 
;; Produz o dobro de n
(check-equal? (dobro 0) 0)
(check-equal? (dobro 4) 8)
(check-equal? (dobro -2) -4)))
;(define (dobro n) 0)
(define (dobro n)
    (... n))

Passo 4: Código do corpo da função

Baseado nos passos anteriores, escrevemos o corpo da função:

;; Número -> número 
;; Produz o dobro de n
(check-equal? (dobro 0) 0)
(check-equal? (dobro 4) 8)
(check-equal? (dobro -2) -4)))
;(define (dobro n) 0)
(define (dobro n)
    (* 2 n))

Abaixo está exibido o programa completo, com as bibliotecas exigidas e as funções de teste para utilizar na IDE DrRacket:

#lang racket
(require rackunit)
(require rackunit/text-ui)

;; Número -> número 
;; Produz o dobro de n.
(define dobro-tests
(test-suite
''dobro tests''
(check-equal? (dobro 0) 0)
(check-equal? (dobro 4) 8)
(check-equal? (dobro -2) -4)))
(define (dobro n)
(* 2 n))

;; Teste ... -> Void
;; Executa um conjunto de testes
(define (executa-testes . testes)
(run-tests (test-suite ''Todos os testes'' testes))
(void))
;; Chama a função para executar os testes
(executa-testes dobro-tests)" "")

        ("Agora já sabemos como fazer funções! Defina uma função de nome ''maior-valor'' que retorne o maior valor entre 2 valores dados." maior-valor "dica"
                        (((1 2) 2)
                         ((6 6) 6)
                         ((123 121) 123)
                         ((-34 -65) -34)
                         ((4 -5) 4)))

        ("Defina uma função de nome ''maior-palavra'' que retorne a maior palavra entre duas palavras dadas." maior-palavra "dica"
                        ((("abc" "roma") "roma")
                         (("casamento" "lebre") "casamento")
                         (("" "dois") "dois")
                         (("telha" "elefante") "elefante")
                         (("" "") "")))

        ("Agora iremos aprender sobre estruturas, ou structs. Estruturas em Racket são usadas para representar dados onde dois ou mais valores precisam estar agrupados, como registros de alunos, placar de jogos, ou informações de produtos.

Declaração de estrutura:

Utiliza-se a forma especial struct para definir estruturas. Exemplo:

(struct ponto (x y))

Construção e uso de estruturas:

Construtor: ponto (no exemplo)
Predicado: ponto? para testar se um valor é do tipo definido.
Seletores: ponto-x e ponto-y para acessar os campos.

Exemplo:

(struct ponto (x y))
(define p1 (ponto 3 4))
(define p2 (ponto 8 2))

> (ponto-x p1)
3
> (ponto-y p1)
4
> (ponto-x p2)
8
> (ponto-y p2)
2
> (ponto? p1)
#t
>(ponto? "ola")
#f


Transparência de Estruturas:

Estruturas são, por padrão, "não transparentes", ou seja, seus campos não são exibidos para preservar encapsulamento. Pode-se usar a palavra-chave #:transparent para tornar a estrutura ''transparente''

Exemplo:

(struct ponto (x y))
> (ponto 3 4)
#<ponto>

(struct ponto (x y) #:transparent)
> (ponto 3 4)
(ponto 3 4)" "")

    ("Agora iremos desenvolver nosso aprendizado sobre estruturas. Para cada afirmação que eu fizer, você de inserir #t se for verdadeira ou #f se for falsa.

Avalie se esta afirmação é verdadeira ou falsa: a função make-struct é uma forma especial em Racket para construção de estruturas." "#f")

    ("Avalie se esta afirmação é verdadeira ou falsa: ao definirmos estruturas em Racket há um construtor, um predicado para testar se um valor é do tipo da estrutura e seletores para acessar os campos da estrutura." "#t")

    ("Que legal Astro, estamos nos aproximando do fim! Veremos como funcionam as listas em Racket:

Elas são estruturas recursivas nas linguagens funcionais. A ideia é que toda lista é formada por dois campos: o primeiro representa um valor da lista e o segundo representa o resto da lista (que é uma lista). É dessa forma que vemos como ela é uma estrutura recursiva.

Podemos construir listas a partir de structs que vimos anteriormente, porém em Racket temos a palavra reservada cons para construir listas:

;; Lista com o elemento 3
> (define lst1 (cons 3 empty))
;; Lista com os elementos 8 e 7
> (define lst2 (cons 8 (cons 7 empty)))
> lst1
'(3)
> lst2
'(8 7)

Manipulação de listas:

Podemos acessar o primeiro elemento de uma lista com a função first e o restante com a função rest.

> (first lst2)
8
> (rest lst2)
’(7)
> (rest (rest lst2))
’()
> (rest lst1)
’()

O Racket oferece uma forma conveniente de criar listas
> (list 4 5 6 -2 20)
’(4 5 6 -2 20)
I Em geral
(list <a1> <a2> ... <an>)
 ́e equivalente a
(cons <a1> (cons <a2> (cons ... (cons <an> empty) ...)))

4. Adição e Remoção de Elementos:

    Use cons para adicionar elementos no início da lista.
    Utilize append para concatenar listas.
    Remova elementos com remove.

    racket

    (define nova-lista (cons 0 numeros))
    (define lista-completa (append numeros '(6 7 8)))
    (define sem-tres (remove 3 numeros))


6. Funções de Lista Preditivas:

    Verifique se uma lista está vazia com empty?.
    Confira o comprimento com length.

    (define vazia? (empty? numeros))   ; Resultado: #f
    (define tamanho (length numeros))  ; Resultado: 5

7. Manipulação Funcional:

    Utilize funções de ordem superior como map, filter, e foldl.

    racket

    (define ao-quadrado (map (lambda (x) (* x x)) numeros))
    (define pares (filter even? numeros))
    (define soma (foldl + 0 numeros))


10. Aninhamento de Listas:

    Crie listas aninhadas para estruturas mais complexas.

    racket

    (define matriz '((1 2 3) (4 5 6) (7 8 9)))" "")

        ("Defina uma função que calcule o fatorial de um n ́umero." "")
        ("Defina uma função que encontre o valor máximo de uma lista de números." "")
        ("Defina uma função que receba como entrada uma lista lst e devolva uma nova lista que
          ́e como lst com apenas uma ocorrˆencia dos elementos repetidos consecutivos.
          > (remove-duplicates (list 1 1 1 1 2 3 3 4 4 5 5 5))
          ’(1 2 3 4 5)." "")
        ("Defina uma fun ̧c ̃ao que receba um ou mais inteiros como parˆametro e retorne uma lista com os parˆametros que tenha a mesma paridade do primeiro argumento. Exemplo
> (same-parity 1 2 3 4 5 6 7)
’(1 3 5 7)
> (same-parity 2 3 4 5 6 7)
’(2 4 6)" "")
        ("
[tspl 2.4.3] Determine o valor da seguinte express ̃ao. Explique como vocˆe chegou neste valor.
(let ([x 9])
(* x
(let ([x (/ x 3)])
(+ x x))))" "")
        ))

(define inicio-jogo #t)
(define texto-canvas "")

(define instrucao-atual-index 0)
(define instrucao-atual (first (first lista-textos)))
(define resposta-certa #f)
(define resposta-errada #f)

; Declaração da posição inicial dos astronautas
(define astro-x 10)
(define astro-y 425)  
(define npc-x 600)
(define npc-y 423)

;; Check if images are close
(define (images-close?)
  (let* ([astronaut-center-x (+ astro-x (/ IMAGE-WIDTH 2))]
         [astronaut-center-y (+ astro-y (/ IMAGE-HEIGHT 2))]
         [standing-astronaut-center-x (+ npc-x (/ IMAGE-WIDTH 2))]
         [standing-astronaut-center-y (+ npc-y (/ IMAGE-HEIGHT 2))]
         [distance (sqrt (+ (sqr (- astronaut-center-x standing-astronaut-center-x))
                            (sqr (- astronaut-center-y standing-astronaut-center-y))))])
    (< distance 75)))

